# goit-algo-hw-04

|Algorithm      |Data Size |Time(sec) |
|---------------|----------|----------|
|Merge Sort     |10        |0.000018  |
|Merge Sort     |100       |0.000248  |
|Merge Sort     |1000      |0.002414  |
|Merge Sort     |10000     |0.026951  |
|Merge Sort     |20000     |0.056031  |
|Merge Sort     |100000    |0.317916  |
|---------------|----------|----------|
|Insertion Sort |10        |0.000008  |
|Insertion Sort |100       |0.000218  |
|Insertion Sort |1000      |0.023418  |
|Insertion Sort |10000     |2.366614  |
|Insertion Sort |20000     |9.543060  |
|Insertion Sort |100000    |error     |
|:--------------|:---------|:---------|
|Timsort        |10        |0.000003  |
|Timsort        |100       |0.000009  |
|Timsort        |1000      |0.000089  |
|Timsort        |10000     |0.001598  |
|Timsort        |20000     |0.002303  |
|Timsort        |100000    |0.012798  |

## Висновоки

# Merge Sort:
Переваги: Ефективний на великих наборах даних, стабільний та гарантовано має асимптотичну складність O(n log n).
Недоліки: Вимагає додаткової пам'яті для злиття, що може бути проблемою для об'єктів великого розміру.

# Insertion Sort:
Переваги: Простий у реалізації, ефективний для вже відсортованих або майже відсортованих наборів даних.
Недоліки: Має квадратичну асимптотичну складність, що робить його не ефективним для великих масивів.

# Timsort:
Переваги: Оптимізований для різних типів даних, адаптивний (працює швидко на практиці), стабільний та гарантовано має асимптотичну складність O(n log n).
Недоліки: Потребує додаткової пам'яті для злиття, але в порівнянні з Merge Sort ця вимога менш велика.

# Загальні висновки:
Залежно від конкретних вимог та властивостей даних, обраний алгоритм сортування може суттєво впливати на продуктивність.
Merge Sort та Timsort зазвичай є ефективними для різних умов та різних типів даних.
Insertion Sort може бути корисним для невеликих масивів або вже відсортованих даних, але для великих наборів його використання недоцільно.